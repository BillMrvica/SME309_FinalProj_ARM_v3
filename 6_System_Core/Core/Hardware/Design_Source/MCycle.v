module MCycle #(
    parameter width = 32
)(
    input CLK, // Connect to CPU clock
    input RESET, // Connect to the reset of the ARM processor.
    
    input Start, // Multi-cycle Enable. The control unit should assert this when MUL or DIV instruction is detected.
    input MCycleOp, // Multi-cycle Operation. "0" for unsigned multiplication, "1" for unsigned division. Generated by Control unit.
    input [width-1:0] Operand1, // Multiplicand / Dividend
    input [width-1:0] Operand2, // Multiplier / Divisor
    
    output [width-1:0] Result, //For MUL, assign the lower-32bits result; For DIV, assign the quotient.
    output Busy, // Set immediately when Start is set. Cleared when the Results become ready. This bit can be used to stall the processor while multi-cycle operations are on.
    output Ready
);

    localparam MUL = 1'b0;
    localparam DIV = 1'b1;

    reg Op;
    reg [width-1:0] Operand1_reg, Operand2_reg;
    reg [(2*width-1):0] imm;
    reg [$clog2(width):0] cnt;

    reg d_Busy;
    always @(posedge CLK) begin
        d_Busy <= Busy;
    end
    assign Ready = ({Busy, d_Busy} == 2'b01) ? 1 : 0;

    always @(posedge CLK or posedge RESET) begin
        if(RESET) begin
            Op <= MUL;
            Operand1_reg <= 0;
            Operand2_reg <= 0;
        end
        else if(Start && (cnt==0)) begin
            Op <= MCycleOp;
            Operand1_reg <= Operand1;
            Operand2_reg <= Operand2;
        end
        else begin
            Op <= Op;
            Operand1_reg <= Operand1_reg;
            Operand2_reg <= Operand2_reg;
        end
    end

    always @(posedge CLK or posedge RESET) begin
        if(RESET) cnt <= 0;
        else if(Start && (cnt==0)) cnt <= cnt + 1;
        else if((cnt >0) && (cnt <=width)) cnt <= cnt + 1;
        else if(cnt == width + 1) cnt <= 0;
        else cnt <= 0;
    end

    wire [width:0] alu_out;
    assign alu_out = (Op == MUL) ? (Operand2_reg + imm[(2*width-1):width]) : ({1'b0, imm[(2*width-1):width]} + ~({1'b0, Operand2_reg}) + 1);
    
    always @(posedge CLK or posedge RESET) begin
        if(RESET) imm <= 0;
        else if(Start && (cnt==0)) imm <= {{(width){1'b0}}, Operand1};
        else if((cnt >0) && (cnt <=width)) begin
            case(Op)
                MUL: imm <= (imm[0]==1) ? ({alu_out, imm[width-1:0]} >> 1) : imm >> 1;
                DIV: imm <= (alu_out[width]==1) ? {imm[(2*width-2):0], 1'b0} : {alu_out[width-2:0], imm[(width-1):0], 1'b1};
            endcase
        end
        else if(cnt == width+1) begin
            case(Op)
                MUL: imm <= imm;
                DIV: imm <= (alu_out[width]==1) ? {imm[(2*width-2):0], 1'b0} : {alu_out[width-2:0], imm[(width-1):0], 1'b1};
            endcase
        end
        else imm <= imm;
    end

    assign Result = imm[(width-1):0];
    assign Busy = ((cnt>0) && (cnt <=width)) || Start;

endmodule
